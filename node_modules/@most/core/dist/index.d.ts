/** @license MIT License (c) copyright 2016 original author or authors */
import { Curried2 } from '@most/prelude';
export { empty } from './source/empty';
export { never } from './source/never';
export { now } from './source/now';
export { at } from './source/at';
export { periodic } from './source/periodic';
export { newStream } from './source/newStream';
export { runEffects } from './runEffects';
interface Run {
    <A>(sink: Sink<A>, scheduler: Scheduler, s: Stream<A>): Disposable;
    <A>(sink: Sink<A>, scheduler: Scheduler): (s: Stream<A>) => Disposable;
    <A>(sink: Sink<A>): Curried2<Scheduler, Stream<A>, Disposable>;
}
export declare const run: Run;
interface WithLocalTime {
    <A>(origin: Time, s: Stream<A>): Stream<A>;
    <A>(origin: Time): (s: Stream<A>) => Stream<A>;
}
export declare const withLocalTime: WithLocalTime;
import { SeedValue } from './combinator/loop';
interface Loop {
    <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>, seed: S, s: Stream<A>): Stream<B>;
    <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>, seed: S): (s: Stream<A>) => Stream<B>;
    <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>): Curried2<S, Stream<A>, Stream<B>>;
}
export declare const loop: Loop;
interface Scan {
    <A, B>(f: (b: B, a: A) => B, b: B, s: Stream<A>): Stream<B>;
    <A, B>(f: (b: B, a: A) => B, b: B): (s: Stream<A>) => Stream<B>;
    <A, B>(f: (b: B, a: A) => B): Curried2<B, Stream<A>, Stream<B>>;
}
export declare const scan: Scan;
interface StartWith {
    <A>(value: A, stream: Stream<A>): Stream<A>;
    <A>(value: A): (stream: Stream<A>) => Stream<A>;
}
export declare const startWith: StartWith;
interface Map {
    <A, B>(f: (a: A) => B, s: Stream<A>): Stream<B>;
    <A, B>(f: (a: A) => B): (s: Stream<A>) => Stream<B>;
}
export declare const map: Map;
interface Constant {
    <A, B>(b: B, s: Stream<A>): Stream<B>;
    <A, B>(b: B): (s: Stream<A>) => Stream<B>;
}
export declare const constant: Constant;
interface Tap {
    <A>(f: (a: A) => any, s: Stream<A>): Stream<A>;
    <A>(f: (a: A) => any): (s: Stream<A>) => Stream<A>;
}
export declare const tap: Tap;
interface Ap {
    <A, B>(streamofFunctions: Stream<(a: A) => B>, streamOfValues: Stream<A>): Stream<B>;
    <A, B>(streamofFunctions: Stream<(a: A) => B>): (streamOfValues: Stream<A>) => Stream<B>;
}
export declare const ap: Ap;
import { join } from './combinator/chain';
interface Chain {
    <A, B>(f: (value: A) => Stream<B>, stream: Stream<A>): Stream<B>;
    <A, B>(f: (value: A) => Stream<B>): (stream: Stream<A>) => Stream<B>;
}
export declare const chain: Chain;
export { join };
interface ContinueWith {
    <A, B = A>(f: () => Stream<B>, s: Stream<A>): Stream<A | B>;
    <A, B = A>(f: () => Stream<B>): (s: Stream<A>) => Stream<A | B>;
}
export declare const continueWith: ContinueWith;
interface ConcatMap {
    <A, B>(f: (a: A) => Stream<B>, stream: Stream<A>): Stream<B>;
    <A, B>(f: (a: A) => Stream<B>): (stream: Stream<A>) => Stream<B>;
}
export declare const concatMap: ConcatMap;
interface MergeConcurrently {
    <A>(concurrency: number, s: Stream<Stream<A>>): Stream<A>;
    <A>(concurrency: number): (s: Stream<Stream<A>>) => Stream<A>;
}
export declare const mergeConcurrently: MergeConcurrently;
interface MergeMapConcurrently {
    <A, B>(f: (a: A) => Stream<B>, concurrency: number, s: Stream<A>): Stream<B>;
    <A, B>(f: (a: A) => Stream<B>, concurrency: number): (s: Stream<A>) => Stream<B>;
    <A, B>(f: (a: A) => Stream<B>): Curried2<number, Stream<A>, Stream<B>>;
}
export declare const mergeMapConcurrently: MergeMapConcurrently;
import { mergeArray } from './combinator/merge';
interface Merge {
    <A, B>(s1: Stream<A>, s2: Stream<B>): Stream<A | B>;
    <A, B>(s1: Stream<A>): (s2: Stream<B>) => Stream<A | B>;
}
export declare const merge: Merge;
export { mergeArray };
interface Combine {
    <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>, b: Stream<B>): Stream<R>;
    <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>): (b: Stream<B>) => Stream<R>;
    <A, B, R>(fn: (a: A, b: B) => R): Curried2<Stream<A>, Stream<B>, Stream<R>>;
}
export declare const combine: Combine;
interface CombineArray {
    <Args extends unknown[], R>(fn: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R>;
    <Args extends unknown[], R>(fn: (...args: Args) => R): (streams: ToStreamsArray<Args>) => Stream<R>;
}
export declare const combineArray: CombineArray;
interface Sample {
    <A, B>(values: Stream<A>, sampler: Stream<B>): Stream<A>;
    <A, B>(values: Stream<A>): (sampler: Stream<B>) => Stream<A>;
}
export declare const sample: Sample;
interface Snapshot {
    <A, B, C>(f: (a: A, b: B) => C, values: Stream<A>, sampler: Stream<B>): Stream<C>;
    <A, B, C>(f: (a: A, b: B) => C, values: Stream<A>): (sampler: Stream<B>) => Stream<C>;
    <A, B, C>(f: (a: A, b: B) => C): Curried2<Stream<A>, Stream<B>, Stream<C>>;
}
export declare const snapshot: Snapshot;
interface ZipItems {
    <A, B, C>(f: (a: A, b: B) => C, a: Array<A>, s: Stream<B>): Stream<C>;
    <A, B, C>(f: (a: A, b: B) => C, a: Array<A>): (s: Stream<B>) => Stream<C>;
    <A, B, C>(f: (a: A, b: B) => C): Curried2<Array<A>, Stream<B>, Stream<C>>;
}
export declare const zipItems: ZipItems;
interface WithItems {
    <A>(a: Array<A>, s: Stream<unknown>): Stream<A>;
    <A>(a: Array<A>): (s: Stream<unknown>) => Stream<A>;
}
export declare const withItems: WithItems;
interface Zip {
    <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>, b: Stream<B>): Stream<R>;
    <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>): (b: Stream<B>) => Stream<R>;
    <A, B, R>(fn: (a: A, b: B) => R): Curried2<Stream<A>, Stream<B>, Stream<R>>;
}
export declare const zip: Zip;
interface ZipArray {
    <Args extends unknown[], R>(fn: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R>;
    <Args extends unknown[], R>(fn: (...args: Args) => R): (streams: ToStreamsArray<Args>) => Stream<R>;
}
export declare const zipArray: ZipArray;
export { switchLatest } from './combinator/switch';
import { skipRepeats } from './combinator/filter';
interface Filter {
    <A, B extends A>(p: (a: A) => a is B, s: Stream<A>): Stream<B>;
    <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>;
    <A, B extends A>(p: (a: A) => a is B): (s: Stream<A>) => Stream<B>;
    <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>;
}
export declare const filter: Filter;
export { skipRepeats };
interface ShipRepeatsWith {
    <A>(eq: (a1: A, a2: A) => boolean, s: Stream<A>): Stream<A>;
    <A>(eq: (a1: A, a2: A) => boolean): (s: Stream<A>) => Stream<A>;
}
export declare const skipRepeatsWith: ShipRepeatsWith;
interface Take {
    <A>(n: number, s: Stream<A>): Stream<A>;
    <A>(n: number): (s: Stream<A>) => Stream<A>;
}
export declare const take: Take;
interface Skip {
    <A>(n: number, s: Stream<A>): Stream<A>;
    <A>(n: number): (s: Stream<A>) => Stream<A>;
}
export declare const skip: Skip;
interface Slice {
    <A>(start: number, end: number, s: Stream<A>): Stream<A>;
    <A>(start: number, end: number): (s: Stream<A>) => Stream<A>;
    <A>(start: number): Curried2<number, Stream<A>, Stream<A>>;
}
export declare const slice: Slice;
interface TakeWhile {
    <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>;
    <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>;
}
export declare const takeWhile: TakeWhile;
interface SkipWhile {
    <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>;
    <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>;
}
export declare const skipWhile: SkipWhile;
interface SkipAfter {
    <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>;
    <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>;
}
export declare const skipAfter: SkipAfter;
interface Until {
    <A>(signal: Stream<any>, s: Stream<A>): Stream<A>;
    <A>(signal: Stream<any>): (s: Stream<A>) => Stream<A>;
}
export declare const until: Until;
interface Since {
    <A>(signal: Stream<any>, s: Stream<A>): Stream<A>;
    <A>(signal: Stream<any>): (s: Stream<A>) => Stream<A>;
}
export declare const since: Since;
interface During {
    <A>(timeWindow: Stream<Stream<any>>, s: Stream<A>): Stream<A>;
    <A>(timeWindow: Stream<Stream<any>>): (s: Stream<A>) => Stream<A>;
}
export declare const during: During;
interface Delay {
    <A>(dt: number, s: Stream<A>): Stream<A>;
    <A>(dt: number): (s: Stream<A>) => Stream<A>;
}
export declare const delay: Delay;
interface Throttle {
    <A>(period: number, s: Stream<A>): Stream<A>;
    <A>(period: number): (s: Stream<A>) => Stream<A>;
}
export declare const throttle: Throttle;
interface Debounce {
    <A>(period: number, s: Stream<A>): Stream<A>;
    <A>(period: number): (s: Stream<A>) => Stream<A>;
}
export declare const debounce: Debounce;
export { fromPromise, awaitPromises } from './combinator/promises';
import { throwError } from './combinator/errors';
interface RecoverWith {
    <A, E extends Error, B = A>(p: (error: E) => Stream<B>, s: Stream<A>): Stream<A | B>;
    <A, E extends Error, B = A>(p: (error: E) => Stream<B>): (s: Stream<A>) => Stream<A | B>;
}
export declare const recoverWith: RecoverWith;
export { throwError };
export { multicast, MulticastSource } from './combinator/multicast';
import { propagateEndTask, PropagateTaskRun, PropagateTask as PropagateTaskResult } from './scheduler/PropagateTask';
import { Stream, Sink, Scheduler, Disposable, Time } from '@most/types';
import { ToStreamsArray } from './combinator/variadic';
interface PropagateTask {
    <A>(run: PropagateTaskRun<A>, value: A, sink: Sink<A>): PropagateTaskResult;
    <A>(run: PropagateTaskRun<A>, value: A): (sink: Sink<A>) => PropagateTaskResult;
    <A>(run: PropagateTaskRun<A>): Curried2<A, Sink<A>, PropagateTaskResult>;
}
export declare const propagateTask: PropagateTask;
interface PropagateEventTask {
    <T>(value: T, sink: Sink<T>): PropagateTaskResult;
    <T>(value: T): (sink: Sink<T>) => PropagateTaskResult;
}
export declare const propagateEventTask: PropagateEventTask;
export declare const propagateErrorTask: Curried2<Error, Sink<unknown>, PropagateTaskResult>;
export { propagateEndTask };
