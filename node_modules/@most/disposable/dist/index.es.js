import { curry2, reduce, concat, append, curry3 } from '@most/prelude';

var dispose = function (disposable) {
    return disposable.dispose();
};

var disposeNone = function () { return NONE; };
var NONE = new (/** @class */ (function () {
    function DisposeNone() {
    }
    DisposeNone.prototype.dispose = function () { };
    return DisposeNone;
}()))();
var isDisposeNone = function (d) {
    return d === NONE;
};

/**
 * Wrap an existing disposable (which may not already have been once()d)
 * so that it will only dispose its underlying resource at most once.
 */
var disposeOnce = function (disposable) {
    return new DisposeOnce(disposable);
};
var DisposeOnce = /** @class */ (function () {
    function DisposeOnce(disposable) {
        this.disposed = false;
        this.disposable = disposable;
    }
    DisposeOnce.prototype.dispose = function () {
        if (!this.disposed) {
            this.disposed = true;
            if (this.disposable) {
                this.disposable.dispose();
                this.disposable = undefined;
            }
        }
    };
    return DisposeOnce;
}());

/** @license MIT License (c) copyright 2010-2017 original author or authors */
/**
 * Create a Disposable that will use the provided
 * dispose function to dispose the resource
 */
var disposeWith = curry2(function (dispose, resource) {
    return disposeOnce(new DisposeWithImpl(dispose, resource));
});
/**
 * Disposable represents a resource that must be
 * disposed/released. It aggregates a function to dispose
 * the resource and a handle to a key/id/handle/reference
 * that identifies the resource
 */
var DisposeWithImpl = /** @class */ (function () {
    function DisposeWithImpl(dispose, resource) {
        this._dispose = dispose;
        this._resource = resource;
    }
    DisposeWithImpl.prototype.dispose = function () {
        this._dispose(this._resource);
    };
    return DisposeWithImpl;
}());

/** @license MIT License (c) copyright 2010 original author or authors */
/**
 * Aggregate a list of disposables into a DisposeAll
 */
var disposeAll = function (ds) {
    var merged = reduce(merge, [], ds);
    return merged.length === 0 ? disposeNone() : new DisposeAll(merged);
};
/**
 * Convenience to aggregate 2 disposables
 */
var disposeBoth = curry2(function (d1, d2) {
    return disposeAll([d1, d2]);
});
var merge = function (ds, d) {
    return isDisposeNone(d) ? ds
        : d instanceof DisposeAll ? concat(ds, d.disposables)
            : append(d, ds);
};
var DisposeAll = /** @class */ (function () {
    function DisposeAll(disposables) {
        this.disposables = disposables;
    }
    DisposeAll.prototype.dispose = function () {
        throwIfErrors(disposeCollectErrors(this.disposables));
    };
    return DisposeAll;
}());
/**
 * Dispose all, safely collecting errors into an array
 */
var disposeCollectErrors = function (disposables) {
    return reduce(appendIfError, [], disposables);
};
/**
 * Call dispose and if throws, append thrown error to errors
 */
var appendIfError = function (errors, d) {
    try {
        d.dispose();
    }
    catch (e) {
        errors.push(e);
    }
    return errors;
};
/**
 * Throw DisposeAllError if errors is non-empty
 * @throws
 */
var throwIfErrors = function (errors) {
    if (errors.length > 0) {
        throw new DisposeAllError(errors.length + " errors", errors);
    }
};
var DisposeAllError = /** @class */ (function () {
    function DisposeAllError(message, errors) {
        this.name = 'DisposeAllError';
        this.message = message;
        this.errors = errors;
        Error.call(this, message);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, DisposeAllError);
        }
        this.stack = "" + this.stack + formatErrorStacks(this.errors);
    }
    return DisposeAllError;
}());
DisposeAllError.prototype = Object.create(Error.prototype);
var formatErrorStacks = function (errors) {
    return reduce(formatErrorStack, '', errors);
};
var formatErrorStack = function (s, e, i) {
    return s + ("\n[" + (i + 1) + "] " + e.stack);
};

/** @license MIT License (c) copyright 2010-2017 original author or authors */
// Try to dispose the disposable.  If it throws, send
// the error to sink.error with the provided Time value
var tryDispose = curry3(function (t, disposable, sink) {
    try {
        disposable.dispose();
    }
    catch (e) {
        sink.error(t, e);
    }
});

export { DisposeAllError, dispose, disposeAll, disposeBoth, disposeNone, disposeOnce, disposeWith, isDisposeNone, tryDispose };
//# sourceMappingURL=index.es.js.map
